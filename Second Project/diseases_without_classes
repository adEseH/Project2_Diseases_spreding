import numpy as np
import matplotlib.pyplot as plt


# Parameters (global): 
alpha = 1/5
beta = 1.72*1/5
gamma = 0.0006

# Transport matrix: [here as in Jakobs example]
#W = np.array([[0,0.53,2.4],[0.93,0,0.3],[8.2,0.58,0]])*10E-4
#print(W)


########## Equations for models (You can see that I wrote the equations into a Numpy array i.e. [dS/dT, dI/dt, dR/dt] = [equation 1, equation 2, equation 3]  
# S = pop[0], I = pop[1], R = pop[2], pop means population

## SIS model: (time, population) 
def SIS_model(t, pop):
    return np.array([-beta*pop[0]*pop[1]/N + alpha*pop[1], beta*pop[0]*pop[1]/N  - alpha*pop[1], 0]) # added a zero as third place to prepare for three variables for the other models and generalize runge kutta

## SIR model:
def SIR_model(t, pop):
    return np.array([-beta*pop[0]*pop[1]/N - gamma*pop[0], beta*pop[0]*pop[1]/N  - alpha*pop[1], gamma*pop[0] + alpha*pop[1]])

## SIR model with travel:
def SIT_model(t, pop):
        return #TO DO


######### Runge Kutta Functions:
# 1. Runge Kutta stepp function (calculates the next time step)
# 2. Runge Kutta Loop function (integration over a certain time with many steps)

# Runge Kutta Step (start time, pop, step size ,model), 
def RungeKuttaStep(t, y, h, model): #y == pop
    # Overall of people:
    n = sum(y) ## Number of people has to stay the same all time
    print(n)
    # ALgorithm stops if overall population changes (TODO: maybe has to be changed)
    #if round(n,0) != N:
    #     print('Population number changed')
    #     exit()

    # Calculation of slopes (k_i are 1 X 3 vectors, where the last row is always zero in case of SIS model) 
    k1 = model(t, y) 
    k2 = model(t + h/2, y + k1*h/2)
    k3 = model(t + h/2, y + k2*h/2)
    k4 = model(t + h, y + k3*h)

    # average slope
    K = 1/6*(k1 + 2.0*k2 + 2.0*k3 + k4)

    # return next time step value ([S, I, R]) 
    return  y + K*h

# Runge Kutta Loop (start time, start pop, step size, overall time, model)
def RungeKuttaLoop(t0, y0, h, T, model = SIS_model):  
    # Number of timesteps and proof if h_step and overall number gives a whole number of time steps. 
    n = T/h
    if n != int(n):                     
        print('Take another overall time pls.')
        exit()
    n = int(n)

    # arrays for time steps and pop - values
    x = np.linspace(t0, T, n+1)   
    y = np.empty((n+1,3))               

    # inital condition and RungeKuttaStep applied N times
    y[0] = y0

    for i in range(1, n+1):
        y[i] = RungeKuttaStep(x[i-1], y[i-1], h, model)
    
    # Return values
    return x, y    

######### main 

# Inital conditions 
t0 = 0
population_0 = np.array([20000000,1,0]) # inital population [S0, I0, R0]
h = 1 # step size [days]
T = 200 # whole time [days]


# Overall population and for prove if overall population number constant and setting this as overall population (maybe important for errror discussion)
global N 
N = round(sum(population_0), 0)
print(N)

# Start Runge Kutta
t, Population  = RungeKuttaLoop(t0, population_0, h, T, SIR_model)



####### Theoretical solution for SIS:
n = int(T/h)
t_SIS = np.linspace(t0, T, n+1)   
pop_SIS = np.empty((n+1,3))                  
pop_SIS[0]  = population_0

I_inf = N*(1-alpha/beta)
r = I_inf/population_0[1] -1
delta = beta - alpha

for i in range(1,len(pop_SIS)): 
    I_i = I_inf/(1 + r*np.exp(-delta*t_SIS[i]))
    pop_SIS[i] = [ N - I_i, I_i ,0]


###### Plot result and compare with theory for SIS: 
# TODO: if SIS model is used R is not plotted and theory is plotted (maybe with gloabl variables by setting model as global variable)
plt.style.use('rc.mplstyle')
fig, ax = plt.subplots(figsize = (3,4))
ax.set_title('Runge Kutta Simulation')
#ax.plot(t_SIS, pop_SIS, label = ['S_theo', 'I_theo', 'R_theo']) #Only for SIS model
ax.plot(t,Population, label = ['S,', 'I', 'R'])
ax.set_xlabel('time t')
ax.set_ylabel('Number individulas')
ax.legend()
plt.show()