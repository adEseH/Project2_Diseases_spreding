import numpy as np
import matplotlib.pyplot as plt


# Parameters (global): 
alpha =  1/9  #1/5
beta =  [0.21,0.26,0.24]  #1.72*1/5
gamma =  [0,0,0]  #0.0013

global N_i

#Transport matrix: [here as in Jakobs example]
W = np.array([[0.0, 5.27324458E-05 ,2.38237046E-04],
 [9.28720687E-05 ,0.0 ,2.97796307E-05],
 [8.17828665E-04, 5.80450430E-05 ,0.0]])*10E-4
#print(W)


########## Equations for models (You can see that I wrote the equations into a Numpy array i.e. [dS/dT, dI/dt, dR/dt] = [equation 1, equation 2, equation 3]  
# S = pop[0], I = pop[1], R = pop[2], pop means population

## SIS model: (time, population) 
def SIS_model(t, pop):
    pop0 = np.array([-beta[0]*pop[0,0]*pop[0,1]/N_i[0] + alpha*pop[0,1], beta[0]*pop[0,0]*pop[0,1]/N_i[0] - alpha*pop[0,1], 0]) # added a zero as third place to prepare for three variables for the other models and generalize runge kutta
    pop1 = np.array([0,0,0])
    pop2 = np.array([0,0,0])
    return np.array([pop0, pop1, pop2])

## SIR model:
def SIR_model(t, pop):
     pop0 = np.array([-beta[0]*pop[0,0]*pop[0,1]/N_i[0] - gamma[0]*pop[0,0], beta[0]*pop[0,0]*pop[0,1]/N_i[0]  - alpha*pop[0,1], gamma[0]*pop[0,0] + alpha*pop[0,1]])
     pop1 = np.array([0,0,0])
     pop2 = np.array([0,0,0])
     return np.array([pop0, pop1, pop2]) 

## SIR model with travel: #Hier Matrix
def SIT_model(t, pop):
        pop0 = np.array([-beta[0]*pop[0,0]*pop[0,1]/N_i[0] - gamma[0]*pop[0,0] +   (W[0,1]*pop[1,0] + W[0,2]*pop[2,0])-(W[1,0] + W[2,0])*pop[0,0], 
                            beta[0]*pop[0,0]*pop[0,1]/N_i[0]  - alpha*pop[0,1]+    (W[0,1]*pop[1,1] + W[0,2]*pop[2,1])-(W[1,0] + W[2,0])*pop[0,1], 
                                gamma[0]*pop[0,0] + alpha*pop[0,1] +              (W[0,1]*pop[1,2] + W[0,2]*pop[2,2])-(W[1,0] + W[2,0])*pop[0,2]])
        
        pop1 = np.array([-beta[1]*pop[1,0]*pop[1,1]/N_i[1] - gamma[1]*pop[1,0] + (W[1,0]*pop[0,0] + W[1,2]*pop[2,0])-(W[0,1] + W[2,1])*pop[1,0], 
                            beta[1]*pop[1,0]*pop[1,1]/N_i[1]  - alpha*pop[1,1]+  (W[1,0]*pop[0,1] + W[1,2]*pop[2,1])-(W[0,1] + W[2,1])*pop[1,1], 
                                            gamma[1]*pop[1,0] + alpha*pop[1,1] + (W[1,0]*pop[0,2] + W[1,2]*pop[2,2])-(W[0,1] + W[2,1])*pop[1,2]])
        
        pop2 = np.array([-beta[2]*pop[2,0]*pop[2,1]/N_i[2] - gamma[2]*pop[2,0] + (W[2,0]*pop[0,0] + W[2,1]*pop[1,0])-(W[0,2] + W[1,2])*pop[2,0], 
                            beta[2]*pop[2,0]*pop[2,1]/N_i[2]  - alpha*pop[2,1]+  (W[2,0]*pop[0,1] + W[2,1]*pop[1,1])-(W[0,2] + W[1,2])*pop[2,1], 
                                            gamma[2]*pop[2,0] + alpha*pop[2,1] + (W[2,0]*pop[0,2] + W[2,1]*pop[1,2])-(W[0,2] + W[1,2])*pop[2,2]])
        

        return np.array([pop0, pop1, pop2]) 

######### Runge Kutta Functions:
# 1. Runge Kutta stepp function (calculates the next time step)
# 2. Runge Kutta Loop function (integration over a certain time with many steps)

# Runge Kutta Step (start time, pop, step size ,model), 
def RungeKuttaStep(t, y, h, model): #y == pop
    # Overall of people:
    n = round(sum(y[0]) +sum(y[1]) +sum(y[2]), 0) ## Number of people has to stay the same all time
    print(n)
    # ALgorithm stops if overall population changes (TODO: maybe has to be changed)
    if round(n,0) != N:
         print('Population number changed')
         exit()

    #Number people different cities
    N_i = np.array([round(sum(y[0]),0), round(sum(y[1]),0) , round(sum(y[2]), 0)])
    print(N_i)

    # Calculation of slopes (k_i are 1 X 3 vectors, where the last row is always zero in case of SIS model) 
    k1 = model(t, y) 
    k2 = model(t + h/2, y + k1*h/2)
    k3 = model(t + h/2, y + k2*h/2)
    k4 = model(t + h, y + k3*h)

    # average slope
    K = 1/6*(k1 + 2.0*k2 + 2.0*k3 + k4)

    # return next time step value ([S, I, R]) 
    return  y + K*h

# Runge Kutta Loop (start time, start pop, step size, overall time, model)
def RungeKuttaLoop(t0, y0, h, T, model = SIS_model):  
    # Number of timesteps and proof if h_step and overall number gives a whole number of time steps. 
    n = T/h
    if n != int(n):                     
        print('Take another overall time pls.')
        exit()
    n = int(n)

    #print(y0)
    # arrays for time steps and pop - values
    x = np.linspace(t0, T, n+1)   
    y = np.empty((n+1,3,3))               

    # inital condition and RungeKuttaStep applied N times
    y[0] = y0

    for i in range(1, n+1):
        y[i] = RungeKuttaStep(x[i-1], y[i-1], h, model)
    
    # Return values
    return x, y   


######### main 

# Inital conditions 
t0 = 0
population_0 = np.array([[6.7E6,10,0],[11.8E6,0,0], [23E6,0,0]]) # inital population [S0, I0, R0]
h = 1 # step size [days]
T = 200 # whole time [days]


# Overall population and for prove if overall population number constant and setting this as overall population (maybe important for errror discussion)
global N 
N = round(sum(population_0[0]) +sum(population_0[1]) +sum(population_0[2]), 0)
print(N)

# Number people of the different cities
N_i = np.array([round(sum(population_0[0]),0), round(sum(population_0[1]),0) , round(sum(population_0[2]), 0)])

# Start Runge Kutta
t, Population  = RungeKuttaLoop(t0, population_0, h, T, SIT_model)


###### Plot result and compare with theory for SIS: 
# TODO: if SIS model is used R is not plotted and theory is plotted (maybe with gloabl variables by setting model as global variable)
plt.style.use('rc.mplstyle')
fig, ax = plt.subplots(figsize = (3,4))
ax.set_title('Runge Kutta Simulation')
#ax.plot(t_SIS, pop_SIS, label = ['S_theo', 'I_theo', 'R_theo']) #Only for SIS model
ax.plot(t,Population[:,0,0:3], label = [ 'S', 'I', 'R'])
ax.plot(t,Population[:,1,0:3], label = ['S', 'I', 'R'])
ax.plot(t,Population[:,2,0:3], label = [ 'S','I', 'R'])
ax.set_xlabel('time t')
ax.set_ylabel('Number individulas')
ax.legend()
plt.show()